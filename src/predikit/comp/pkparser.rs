// This file was generated by Peginator v0.7.0 built at 1733090023
// CRC-32/ISO-HDLC of the grammar file: c44c7fa8
// Any changes to it will be lost on regeneration

#![allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Whitespace;
#[derive(Debug, Clone)]
pub struct Comment;
pub type PkCheckFn = String;
pub type PkParamName = String;
pub type PkStringLit = String;
pub type PkParamTypeBool = String;
pub type PkParamTypeInt = String;
pub type PkParamTypeString = String;
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum PkTypedParamValue {
    PkParamTypeBool(PkParamTypeBool),
    PkParamTypeInt(PkParamTypeInt),
    PkParamTypeString(PkParamTypeString),
}
#[derive(Debug, Clone)]
pub struct PkCheckParam {
    pub param_name: PkParamName,
    pub param_typed_value: PkTypedParamValue,
}
#[derive(Debug, Clone)]
pub struct PkCheckParams {
    pub params: Vec<PkCheckParam>,
}
pub type PkNegate = String;
#[derive(Debug, Clone)]
pub struct PkCheckDef {
    pub negate: Option<PkNegate>,
    pub check_fn: PkCheckFn,
    pub params: PkCheckParams,
}
pub type PkAggType = String;
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum PkChild {
    PkCheckDef(PkCheckDef),
    PkGroup(PkGroup),
}
#[derive(Debug, Clone)]
pub struct PkGroup {
    pub agg_type: PkAggType,
    pub group_params: PkCheckParams,
    pub children: Vec<PkChild>,
}
#[derive(Debug, Clone)]
pub struct PkFile {
    pub groups: Vec<PkGroup>,
}
impl peginator_generated::PegParserAdvanced<()> for PkTypedParamValue {
    fn parse_advanced<TT: peginator_generated::ParseTracer>(
        s: &str,
        settings: &peginator_generated::ParseSettings,
        user_context: (),
    ) -> Result<Self, peginator_generated::ParseError> {
        Ok(peginator_generated::parse_PkTypedParamValue(
            peginator_generated::ParseState::new(s, settings),
            &mut peginator_generated::ParseGlobal::<TT, peginator_generated::ParseCache, ()>::new(
                Default::default(),
                user_context,
            ),
        )?
        .result)
    }
}
impl peginator_generated::PegParserAdvanced<()> for PkCheckParam {
    fn parse_advanced<TT: peginator_generated::ParseTracer>(
        s: &str,
        settings: &peginator_generated::ParseSettings,
        user_context: (),
    ) -> Result<Self, peginator_generated::ParseError> {
        Ok(peginator_generated::parse_PkCheckParam(
            peginator_generated::ParseState::new(s, settings),
            &mut peginator_generated::ParseGlobal::<TT, peginator_generated::ParseCache, ()>::new(
                Default::default(),
                user_context,
            ),
        )?
        .result)
    }
}
impl peginator_generated::PegParserAdvanced<()> for PkCheckParams {
    fn parse_advanced<TT: peginator_generated::ParseTracer>(
        s: &str,
        settings: &peginator_generated::ParseSettings,
        user_context: (),
    ) -> Result<Self, peginator_generated::ParseError> {
        Ok(peginator_generated::parse_PkCheckParams(
            peginator_generated::ParseState::new(s, settings),
            &mut peginator_generated::ParseGlobal::<TT, peginator_generated::ParseCache, ()>::new(
                Default::default(),
                user_context,
            ),
        )?
        .result)
    }
}
impl peginator_generated::PegParserAdvanced<()> for PkCheckDef {
    fn parse_advanced<TT: peginator_generated::ParseTracer>(
        s: &str,
        settings: &peginator_generated::ParseSettings,
        user_context: (),
    ) -> Result<Self, peginator_generated::ParseError> {
        Ok(peginator_generated::parse_PkCheckDef(
            peginator_generated::ParseState::new(s, settings),
            &mut peginator_generated::ParseGlobal::<TT, peginator_generated::ParseCache, ()>::new(
                Default::default(),
                user_context,
            ),
        )?
        .result)
    }
}
impl peginator_generated::PegParserAdvanced<()> for PkChild {
    fn parse_advanced<TT: peginator_generated::ParseTracer>(
        s: &str,
        settings: &peginator_generated::ParseSettings,
        user_context: (),
    ) -> Result<Self, peginator_generated::ParseError> {
        Ok(peginator_generated::parse_PkChild(
            peginator_generated::ParseState::new(s, settings),
            &mut peginator_generated::ParseGlobal::<TT, peginator_generated::ParseCache, ()>::new(
                Default::default(),
                user_context,
            ),
        )?
        .result)
    }
}
impl peginator_generated::PegParserAdvanced<()> for PkGroup {
    fn parse_advanced<TT: peginator_generated::ParseTracer>(
        s: &str,
        settings: &peginator_generated::ParseSettings,
        user_context: (),
    ) -> Result<Self, peginator_generated::ParseError> {
        Ok(peginator_generated::parse_PkGroup(
            peginator_generated::ParseState::new(s, settings),
            &mut peginator_generated::ParseGlobal::<TT, peginator_generated::ParseCache, ()>::new(
                Default::default(),
                user_context,
            ),
        )?
        .result)
    }
}
impl peginator_generated::PegParserAdvanced<()> for PkFile {
    fn parse_advanced<TT: peginator_generated::ParseTracer>(
        s: &str,
        settings: &peginator_generated::ParseSettings,
        user_context: (),
    ) -> Result<Self, peginator_generated::ParseError> {
        Ok(peginator_generated::parse_PkFile(
            peginator_generated::ParseState::new(s, settings),
            &mut peginator_generated::ParseGlobal::<TT, peginator_generated::ParseCache, ()>::new(
                Default::default(),
                user_context,
            ),
        )?
        .result)
    }
}
#[allow(
    non_snake_case,
    unused_variables,
    unused_imports,
    unused_mut,
    dead_code
)]
mod peginator_generated {
    use super::*;
    use peginator::*;
    pub use peginator::{
        IndentedTracer, ParseError, ParseGlobal, ParseSettings, ParseState, ParseTracer, PegParser,
        PegParserAdvanced, PegPosition,
    };
    #[derive(Default)]
    pub struct ParseCache<'a> {
        _please_dont_complain: std::marker::PhantomData<&'a ()>,
    }
    mod Whitespace_impl {
        use super::*;
        mod closure {
            use super::*;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let mut iterations: usize = 0;
            let mut state = state;
            loop {
                match ChoiceHelper::new(state.clone())
                    .choice(|state| parse_Comment(state, &mut *global).discard_result())
                    .choice(|state| parse_character_literal(state, '\t').discard_result())
                    .choice(|state| parse_character_literal(state, '\n').discard_result())
                    .choice(|state| parse_character_literal(state, '\u{c}').discard_result())
                    .choice(|state| parse_character_literal(state, '\r').discard_result())
                    .choice(|state| parse_character_literal(state, ' ').discard_result())
                    .end()
                {
                    Ok(ParseOk {
                        result: __result,
                        state: new_state,
                        ..
                    }) => {
                        state = new_state;
                    }
                    Err(err) => {
                        state = state.record_error(err);
                        break;
                    }
                }
                iterations += 1;
            }
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_Whitespace<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Whitespace> {
        global.tracer.print_trace_start(&state, "Whitespace");
        let result = (|| {
            let result = Whitespace_impl::parse(state, global)?.map(|r| super::Whitespace {});
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod Comment_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
                mod part_0 {
                    use super::*;
                    mod negative_lookahead {
                        use super::*;
                        #[inline(always)]
                        pub fn parse<'a, TT: ParseTracer>(
                            state: ParseState<'a>,
                            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                        ) -> ParseResult<'a, Parsed> {
                            parse_character_literal(state, '\n').discard_result()
                        }
                        pub type Parsed = ();
                    }
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        match negative_lookahead::parse(state.clone(), global) {
                            Ok(_) => {
                                Err(state
                                    .report_error(ParseErrorSpecifics::NegativeLookaheadFailed))
                            }
                            Err(_) => Ok(ParseOk { result: (), state }),
                        }
                    }
                    pub type Parsed = ();
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = part_0::parse(state, global)?;
                    let ParseOk { state, .. } = parse_char(state, &mut *global).discard_result()?;
                    Ok(ParseOk { result: (), state })
                }
                pub type Parsed = ();
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                loop {
                    match closure::parse(state.clone(), global) {
                        Ok(ParseOk {
                            result: __result,
                            state: new_state,
                            ..
                        }) => {
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_string_literal(state, "//").discard_result()?;
            let ParseOk { state, .. } = part_1::parse(state, global)?;
            let ParseOk { state, .. } = parse_character_literal(state, '\n').discard_result()?;
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_Comment<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Comment> {
        global.tracer.print_trace_start(&state, "Comment");
        let result = (|| {
            let result = Comment_impl::parse(state, global)?.map(|r| super::Comment {});
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod PkCheckFn_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                loop {
                    match ChoiceHelper::new(state.clone())
                        .choice(|state| parse_character_range(state, 'a', 'z').discard_result())
                        .choice(|state| parse_character_range(state, 'A', 'Z').discard_result())
                        .choice(|state| parse_character_range(state, '0', '9').discard_result())
                        .choice(|state| parse_character_literal(state, '_').discard_result())
                        .choice(|state| parse_character_literal(state, '.').discard_result())
                        .choice(|state| parse_character_literal(state, '!').discard_result())
                        .choice(|state| parse_character_literal(state, '?').discard_result())
                        .end()
                    {
                        Ok(ParseOk {
                            result: __result,
                            state: new_state,
                            ..
                        }) => {
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                if iterations == 0 {
                    return Err(state.report_farthest_error());
                }
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_character_range(state, 'a', 'z').discard_result()?;
            let ParseOk { state, .. } = part_1::parse(state, global)?;
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_PkCheckFn<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, PkCheckFn> {
        global.tracer.print_trace_start(&state, "PkCheckFn");
        let result = (|| {
            let result =
                PkCheckFn_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                    let string = state.slice_until(new_state).to_string();
                    string
                });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod PkParamName_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_character_literal(state, ':').discard_result()?;
            let ParseOk {
                result: fn_name,
                state,
            } = parse_PkCheckFn(state, &mut *global)?;
            Ok(ParseOk {
                result: fn_name,
                state,
            })
        }
        pub type Parsed = PkCheckFn;
    }
    #[inline]
    pub(super) fn parse_PkParamName<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, PkParamName> {
        global.tracer.print_trace_start(&state, "PkParamName");
        let result = (|| {
            let result =
                PkParamName_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                    let string = state.slice_until(new_state).to_string();
                    string
                });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod PkStringLit_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
                mod part_0 {
                    use super::*;
                    mod negative_lookahead {
                        use super::*;
                        #[inline(always)]
                        pub fn parse<'a, TT: ParseTracer>(
                            state: ParseState<'a>,
                            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                        ) -> ParseResult<'a, Parsed> {
                            ChoiceHelper::new(state)
                                .choice(|state| {
                                    parse_character_literal(state, '"').discard_result()
                                })
                                .choice(|state| {
                                    parse_character_literal(state, '\n').discard_result()
                                })
                                .end()
                        }
                        pub type Parsed = ();
                    }
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        match negative_lookahead::parse(state.clone(), global) {
                            Ok(_) => {
                                Err(state
                                    .report_error(ParseErrorSpecifics::NegativeLookaheadFailed))
                            }
                            Err(_) => Ok(ParseOk { result: (), state }),
                        }
                    }
                    pub type Parsed = ();
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = part_0::parse(state, global)?;
                    let ParseOk {
                        result: mut c,
                        state,
                    } = parse_char(state, &mut *global).map_inner(|result| vec![result])?;
                    Ok(ParseOk { result: c, state })
                }
                pub type Parsed = Vec<char>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut c: Vec<char> = Vec::new();
                loop {
                    match closure::parse(state.clone(), global) {
                        Ok(ParseOk {
                            result: __result,
                            state: new_state,
                            ..
                        }) => {
                            c.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: c, state })
            }
            pub type Parsed = Vec<char>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_character_literal(state, '"').discard_result()?;
            let ParseOk {
                result: mut c,
                state,
            } = part_1::parse(state, global)?;
            let ParseOk { state, .. } = parse_character_literal(state, '"').discard_result()?;
            Ok(ParseOk { result: c, state })
        }
        pub type Parsed = Vec<char>;
    }
    #[inline]
    pub(super) fn parse_PkStringLit<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, PkStringLit> {
        global.tracer.print_trace_start(&state, "PkStringLit");
        let result = (|| {
            let result =
                PkStringLit_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                    let string = state.slice_until(new_state).to_string();
                    string
                });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod PkParamTypeBool_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "true"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "false"))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_PkParamTypeBool<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, PkParamTypeBool> {
        global.tracer.print_trace_start(&state, "PkParamTypeBool");
        let result = (|| {
            let result = PkParamTypeBool_impl::parse(state.clone(), global)?.map_with_state(
                |_, new_state| {
                    let string = state.slice_until(new_state).to_string();
                    string
                },
            );
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod PkParamTypeInt_impl {
        use super::*;
        mod closure {
            use super::*;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let mut iterations: usize = 0;
            let mut state = state;
            loop {
                match parse_Whitespace(state.clone(), &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_range(state, '0', '9'))
                    .discard_result()
                {
                    Ok(ParseOk {
                        result: __result,
                        state: new_state,
                        ..
                    }) => {
                        state = new_state;
                    }
                    Err(err) => {
                        state = state.record_error(err);
                        break;
                    }
                }
                iterations += 1;
            }
            if iterations == 0 {
                return Err(state.report_farthest_error());
            }
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_PkParamTypeInt<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, PkParamTypeInt> {
        global.tracer.print_trace_start(&state, "PkParamTypeInt");
        let result = (|| {
            let result = PkParamTypeInt_impl::parse(state.clone(), global)?.map_with_state(
                |_, new_state| {
                    let string = state.slice_until(new_state).to_string();
                    string
                },
            );
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod PkParamTypeString_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
                mod part_0 {
                    use super::*;
                    mod negative_lookahead {
                        use super::*;
                        #[inline(always)]
                        pub fn parse<'a, TT: ParseTracer>(
                            state: ParseState<'a>,
                            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                        ) -> ParseResult<'a, Parsed> {
                            ChoiceHelper::new(state)
                                .choice(|state| {
                                    parse_character_literal(state, '"').discard_result()
                                })
                                .choice(|state| {
                                    parse_character_literal(state, '\n').discard_result()
                                })
                                .end()
                        }
                        pub type Parsed = ();
                    }
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        match negative_lookahead::parse(state.clone(), global) {
                            Ok(_) => {
                                Err(state
                                    .report_error(ParseErrorSpecifics::NegativeLookaheadFailed))
                            }
                            Err(_) => Ok(ParseOk { result: (), state }),
                        }
                    }
                    pub type Parsed = ();
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = part_0::parse(state, global)?;
                    let ParseOk {
                        result: mut c,
                        state,
                    } = parse_char(state, &mut *global).map_inner(|result| vec![result])?;
                    Ok(ParseOk { result: c, state })
                }
                pub type Parsed = Vec<char>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut c: Vec<char> = Vec::new();
                loop {
                    match closure::parse(state.clone(), global) {
                        Ok(ParseOk {
                            result: __result,
                            state: new_state,
                            ..
                        }) => {
                            c.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: c, state })
            }
            pub type Parsed = Vec<char>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_character_literal(state, '"').discard_result()?;
            let ParseOk {
                result: mut c,
                state,
            } = part_1::parse(state, global)?;
            let ParseOk { state, .. } = parse_character_literal(state, '"').discard_result()?;
            Ok(ParseOk { result: c, state })
        }
        pub type Parsed = Vec<char>;
    }
    #[inline]
    pub(super) fn parse_PkParamTypeString<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, PkParamTypeString> {
        global.tracer.print_trace_start(&state, "PkParamTypeString");
        let result = (|| {
            let result = PkParamTypeString_impl::parse(state.clone(), global)?.map_with_state(
                |_, new_state| {
                    let string = state.slice_until(new_state).to_string();
                    string
                },
            );
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod PkTypedParamValue_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| {
                            parse_PkParamTypeBool(state, &mut *global)
                        })
                        .map_inner(Parsed__override::PkParamTypeBool)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_PkParamTypeInt(state, &mut *global))
                        .map_inner(Parsed__override::PkParamTypeInt)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| {
                            parse_PkParamTypeString(state, &mut *global)
                        })
                        .map_inner(Parsed__override::PkParamTypeString)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::PkTypedParamValue as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_PkTypedParamValue<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, PkTypedParamValue> {
        global.tracer.print_trace_start(&state, "PkTypedParamValue");
        let result = (|| {
            let result = PkTypedParamValue_impl::parse(state, global)?;
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod PkCheckParam_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk {
                result: param_name,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_PkParamName(state, &mut *global))?;
            let ParseOk {
                result: param_typed_value,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_PkTypedParamValue(state, &mut *global))?;
            Ok(ParseOk {
                result: Parsed {
                    param_name,
                    param_typed_value,
                },
                state,
            })
        }
        pub struct Parsed {
            pub param_name: PkParamName,
            pub param_typed_value: PkTypedParamValue,
        }
    }
    #[inline]
    pub(super) fn parse_PkCheckParam<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, PkCheckParam> {
        global.tracer.print_trace_start(&state, "PkCheckParam");
        let result = (|| {
            let result = PkCheckParam_impl::parse(state, global)?.map(|r| super::PkCheckParam {
                param_name: r.param_name,
                param_typed_value: r.param_typed_value,
            });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod PkCheckParams_impl {
        use super::*;
        mod closure {
            use super::*;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let mut iterations: usize = 0;
            let mut state = state;
            let mut params: Vec<PkCheckParam> = Vec::new();
            loop {
                match parse_Whitespace(state.clone(), &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_PkCheckParam(state, &mut *global))
                    .map_inner(|result| vec![result])
                {
                    Ok(ParseOk {
                        result: __result,
                        state: new_state,
                        ..
                    }) => {
                        params.extend(__result);
                        state = new_state;
                    }
                    Err(err) => {
                        state = state.record_error(err);
                        break;
                    }
                }
                iterations += 1;
            }
            Ok(ParseOk {
                result: params,
                state,
            })
        }
        pub type Parsed = Vec<PkCheckParam>;
    }
    #[inline]
    pub(super) fn parse_PkCheckParams<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, PkCheckParams> {
        global.tracer.print_trace_start(&state, "PkCheckParams");
        let result = (|| {
            let result = PkCheckParams_impl::parse(state, global)?
                .map(|r| super::PkCheckParams { params: r });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod PkNegate_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "not"))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_PkNegate<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, PkNegate> {
        global.tracer.print_trace_start(&state, "PkNegate");
        let result = (|| {
            let result =
                PkNegate_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                    let string = state.slice_until(new_state).to_string();
                    string
                });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod PkCheckDef_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "check"))
                .discard_result()?;
            let ParseOk {
                result: negate,
                state,
            } = parse_Whitespace(state.clone(), &mut *global)
                .and_then(|ParseOk { state, .. }| parse_PkNegate(state, &mut *global))
                .map_inner(Some)
                .or_else(|err| {
                    Ok(ParseOk {
                        result: Default::default(),
                        state: state.record_error(err),
                    })
                })?;
            let ParseOk {
                result: check_fn,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_PkCheckFn(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '{'))
                .discard_result()?;
            let ParseOk {
                result: params,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_PkCheckParams(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '}'))
                .discard_result()?;
            Ok(ParseOk {
                result: Parsed {
                    negate,
                    check_fn,
                    params,
                },
                state,
            })
        }
        pub struct Parsed {
            pub negate: Option<PkNegate>,
            pub check_fn: PkCheckFn,
            pub params: PkCheckParams,
        }
    }
    #[inline]
    pub(super) fn parse_PkCheckDef<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, PkCheckDef> {
        global.tracer.print_trace_start(&state, "PkCheckDef");
        let result = (|| {
            let result = PkCheckDef_impl::parse(state, global)?.map(|r| super::PkCheckDef {
                negate: r.negate,
                check_fn: r.check_fn,
                params: r.params,
            });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod PkAggType_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "all"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "any"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "none"))
                        .discard_result()
                })
                .end()?;
            let ParseOk { state, .. } = parse_Whitespace(state.clone(), &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '@'))
                .discard_result()
                .or_else(|err| {
                    Ok(ParseOk {
                        result: (),
                        state: state.record_error(err),
                    })
                })?;
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_PkAggType<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, PkAggType> {
        global.tracer.print_trace_start(&state, "PkAggType");
        let result = (|| {
            let result =
                PkAggType_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                    let string = state.slice_until(new_state).to_string();
                    string
                });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod PkChild_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_PkCheckDef(state, &mut *global))
                        .map_inner(Parsed__override::PkCheckDef)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_PkGroup(state, &mut *global))
                        .map_inner(Parsed__override::PkGroup)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::PkChild as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_PkChild<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, PkChild> {
        global.tracer.print_trace_start(&state, "PkChild");
        let result = (|| {
            let result = PkChild_impl::parse(state, global)?;
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod PkGroup_impl {
        use super::*;
        mod part_3 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut children: Vec<PkChild> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_PkChild(state, &mut *global))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk {
                            result: __result,
                            state: new_state,
                            ..
                        }) => {
                            children.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk {
                    result: children,
                    state,
                })
            }
            pub type Parsed = Vec<PkChild>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk {
                result: agg_type,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_PkAggType(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '{'))
                .discard_result()?;
            let ParseOk {
                result: group_params,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_PkCheckParams(state, &mut *global))?;
            let ParseOk {
                result: mut children,
                state,
            } = part_3::parse(state, global)?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '}'))
                .discard_result()?;
            Ok(ParseOk {
                result: Parsed {
                    agg_type,
                    group_params,
                    children,
                },
                state,
            })
        }
        pub struct Parsed {
            pub agg_type: PkAggType,
            pub group_params: PkCheckParams,
            pub children: Vec<PkChild>,
        }
    }
    #[inline]
    pub(super) fn parse_PkGroup<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, PkGroup> {
        global.tracer.print_trace_start(&state, "PkGroup");
        let result = (|| {
            let result = PkGroup_impl::parse(state, global)?.map(|r| super::PkGroup {
                agg_type: r.agg_type,
                group_params: r.group_params,
                children: r.children,
            });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod PkFile_impl {
        use super::*;
        mod part_0 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut groups: Vec<PkGroup> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_PkGroup(state, &mut *global))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk {
                            result: __result,
                            state: new_state,
                            ..
                        }) => {
                            groups.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                if iterations == 0 {
                    return Err(state.report_farthest_error());
                }
                Ok(ParseOk {
                    result: groups,
                    state,
                })
            }
            pub type Parsed = Vec<PkGroup>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk {
                result: mut groups,
                state,
            } = part_0::parse(state, global)?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_end_of_input(state))?;
            Ok(ParseOk {
                result: groups,
                state,
            })
        }
        pub type Parsed = Vec<PkGroup>;
    }
    #[inline]
    pub(super) fn parse_PkFile<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, PkFile> {
        global.tracer.print_trace_start(&state, "PkFile");
        let result = (|| {
            let result = PkFile_impl::parse(state, global)?.map(|r| super::PkFile { groups: r });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
}
